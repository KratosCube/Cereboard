@using Cereboard.Shared.Models
@using Cereboard.Components.Dialogs
@inject IJSRuntime JS
@implements IAsyncDisposable

<style>
    .task-detail-dialog {
        height: 90vh;
        width: 90vw;
        max-width: 1200px;
        overflow: hidden; /* Odstranění scrollbarů */
    }

    .task-content-container {
        display: flex;
        height: calc(90vh - 130px);
        overflow: hidden; /* Odstranění scrollbarů */
    }

    .actions-sidebar {
        width: 200px;
        padding-right: 16px;
        border-right: 1px solid var(--mud-palette-lines-default);
        overflow-y: auto;
    }

    .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        padding-left: 16px;
    }

    .description-container {
        min-height: 250px;
        flex-grow: 0;
        flex-shrink: 1;
        overflow-y: auto;
        margin-bottom: 16px;
        width: 100%;
        max-height: 50vh;
    }

    .comments-container {
        flex: 1;
        overflow-y: auto;
        width: 100%;
    }

    .comment-item {
        margin-bottom: 16px;
        border-left: 3px solid var(--mud-palette-primary);
        padding-left: 8px;
    }

    .comment-reply {
        margin-left: 32px;
        margin-top: 8px;
        border-left: 2px solid var(--mud-palette-secondary);
        padding-left: 8px;
    }

    .comment-reply .comment-reply {
        margin-left: 24px; /* Menší odsazení pro hlubší úrovně */
        border-left-color: var(--mud-palette-tertiary);
    }

    .comment-header {
        display: flex;
        align-items: center;
    }

    .comment-avatar {
        margin-right: 8px;
    }

    .markdown-area {
        min-height: 100px;
        border: 1px solid var(--mud-palette-lines-default);
        border-radius: 4px;
        padding: 8px;
        overflow-y: auto;
    }

    .format-btn {
        margin: 4px 0;
    }

    .markdown-preview a {
        color: var(--mud-palette-primary);
        text-decoration: underline;
    }

    .markdown-preview code {
        background-color: var(--mud-palette-surface);
        padding: 0.2em 0.4em;
        border-radius: 3px;
    }

    .markdown-preview pre {
        background-color: var(--mud-palette-surface);
        padding: 1em;
        border-radius: 4px;
        overflow-x: auto;
    }

    .markdown-preview h1 {
        font-size: 1.8em;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        font-weight: bold;
    }

    .markdown-preview h2 {
        font-size: 1.5em;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        font-weight: bold;
    }

    .mud-input-control {
        height: auto !important;
    }

    .mud-input.mud-input-outlined .mud-input-slot {
        height: auto !important;
    }

    .markdown-preview img {
        max-width: 100%;
        border-radius: 4px;
        display: block;
        margin: 8px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .image-placeholder {
        background-color: #f0f0f0;
        min-height: 100px;
        min-width: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        font-style: italic;
    }
</style>

<MudDialog FullWidth="true" MaxWidth="MaxWidth.ExtraLarge" Class="task-detail-dialog">
    <TitleContent>
        <div class="d-flex align-center w-100">
            @if (editingTitle)
            {
                    <MudTextField @bind-Value="task.Title" Immediate="true" Variant="Variant.Outlined" Class="flex-grow-1 mr-2" AutoFocus="true" 
                                  @onkeydown="@(e => { if(e.Key == "Enter") { editingTitle = false; } })" />
                    <MudIconButton Icon="@Icons.Material.Filled.Check" Color="Color.Success" Size="Size.Small" OnClick="@(() => editingTitle = false)" />
            }
            else
            {
                    <MudText Typo="Typo.h5">@task.Title</MudText>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit" Color="Color.Default" Size="Size.Small" Class="ml-2" OnClick="@(() => editingTitle = true)" />
            }
        </div>
    </TitleContent>

    <DialogContent>
        <div class="pa-0 task-content-container">
            <!-- Levý panel s nástroji -->
            <div class="actions-sidebar pa-2">
                <MudText Typo="Typo.subtitle1" Class="mb-2">Formátování</MudText>

                <MudButton OnClick="@(() => InsertMarkdownAsync("**", "**"))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.FormatBold" Class="mr-2" /> Tučný
                </MudButton>

                <MudButton OnClick="@(() => InsertMarkdownAsync("*", "*"))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.FormatItalic" Class="mr-2" /> Kurzíva
                </MudButton>

                <MudButton OnClick="@(() => InsertMarkdownAsync("~~", "~~"))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.FormatStrikethrough" Class="mr-2" /> Přeškrtnuté
                </MudButton>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle1" Class="mb-2">Seznamy</MudText>

                <MudButton OnClick="@(() => InsertMarkdownAsync("\n- ", ""))" FullWidth="true"
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.FormatListBulleted" Class="mr-2" /> Odrážky
                </MudButton>

                <MudButton OnClick="@(() => InsertMarkdownAsync("\n1. ", ""))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.FormatListNumbered" Class="mr-2" /> Číslování
                </MudButton>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle1" Class="mb-2">Speciální</MudText>

                <MudButton OnClick="@(() => InsertMarkdownAsync("[", "](https://example.com)"))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.Link" Class="mr-2" /> Odkaz
                </MudButton>

                <MudButton OnClick="@(() => InsertImage())" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.Image" Class="mr-2" /> Obrázek
                </MudButton>

                <MudButton OnClick="@(() => InsertMarkdownAsync("```\n", "\n```"))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    <MudIcon Icon="@Icons.Material.Filled.Code" Class="mr-2" /> Kód
                </MudButton>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle1" Class="mb-2">Nadpisy</MudText>

                <MudButton OnClick="@(() => InsertMarkdownAsync("\n# ", ""))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    Nadpis 1
                </MudButton>

                <MudButton OnClick="@(() => InsertMarkdownAsync("\n## ", ""))" FullWidth="true" 
                           Variant="Variant.Outlined" Size="Size.Small" Class="format-btn">
                    Nadpis 2
                </MudButton>

                <MudDivider Class="my-3" />

                <MudText Typo="Typo.subtitle1" Class="mb-2">Barvy</MudText>

                <div class="d-flex flex-wrap justify-space-between">
                    @foreach (var color in colors)
                    {
                            <MudButton OnClick="@(() => InsertMarkdownAsync($"<span style=\"color: {color};\">", "</span>"))"
                                     Style="@($"background-color: {color}; min-width: 32px; height: 32px; margin: 2px;")" />
                    }
                </div>
            </div>

            <!-- Hlavní obsah -->
            <div class="main-content">
                <!-- Popis úkolu -->
                <MudText Typo="Typo.h6" Class="mt-2">Popis</MudText>

                <div class="description-container">
                    @if (editingDescription)
                    {
                            <MudTextField @bind-Value="task.Description" Lines="8" Variant="Variant.Outlined" 
                                        Immediate="true" Class="w-100 description-editor" MinRows="8" MaxRows="20" 
                                        @onfocus="@(() => activeEditor = "description")"
                                        @ref="descriptionTextAreaRef" id="description-textarea"
                                        @onkeydown="@(e => HandleKeyDownWithPreventDefault(e, "description"))" />

                            <div class="d-flex justify-end mt-2">
                                <MudButton Variant="Variant.Text" Color="Color.Default" 
                                          OnClick="@(() => editingDescription = false)">Hotovo</MudButton>
                            </div>
                    }
                    else
                    {
                            <div id="markdown-preview" class="markdown-area markdown-preview" @onclick="@(() => { editingDescription = true; })">
                            @((MarkupString)htmlPreview)
                            </div>
                    }
                </div>

                <!-- Komentáře -->
                <MudText Typo="Typo.h6" Class="mb-3">Komentáře</MudText>

                <div class="comments-container">
                    <!-- Přidání nového komentáře -->
                    <div class="d-flex mb-4">
                        <MudAvatar Color="Color.Primary" Class="mr-3">A</MudAvatar>
                        <div class="flex-grow-1">
                            <MudTextField @bind-Value="newComment" Placeholder="Přidat komentář..."
                                        Lines="3" Variant="Variant.Outlined" Class="mb-2"
                                        @onfocus="@(() => activeEditor = "newComment")"
                                        @ref="newCommentTextAreaRef" id="new-comment-textarea"
                                        @onkeydown="@(e => HandleKeyDownWithPreventDefault(e, "newComment"))" />
                            <div class="d-flex justify-end">
                                <MudButton Variant="Variant.Filled" Color="Color.Primary" 
                                          OnClick="AddComment" Disabled="@(string.IsNullOrWhiteSpace(newComment))">
                                    Přidat komentář
                                </MudButton>
                            </div>
                        </div>
                    </div>

                    <!-- Seznam komentářů -->
                    @foreach (var comment in comments.Where(c => c.ParentCommentId == null).OrderByDescending(c => c.CreatedAt))
                    {
                            <div class="comment-item">
                                <CommentComponent Comment="comment" 
                                                 Comments="comments" 
                                                 EditingCommentId="editingCommentId" 
                                                 ReplyingToId="replyingToId" 
                                                 OnSetReplyingTo="SetReplyingTo" 
                                                 OnSetEditingComment="SetEditingComment" 
                                                 OnDeleteComment="DeleteComment" 
                                                 OnAddReply="AddReply" 
                                                 OnHandleKeyDown="HandleKeyDownWithPreventDefault" 
                                                 ActiveEditor="activeEditor" 
                                                 OnSetActiveEditor="SetActiveEditor" 
                                                 ReplyText="replyText" 
                                                 OnReplyTextChanged="UpdateReplyText" />
                            </div>
                    }
                </div>
            </div>
        </div>
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel">Zavřít</MudButton>
        <MudButton Color="Color.Primary" OnClick="Submit">Uložit</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public TaskItem task { get; set; } = new();

    // Reference na text oblasti
    private MudTextField<string>? descriptionTextAreaRef;
    private MudTextField<string>? newCommentTextAreaRef;
    private MudTextField<string>? replyTextAreaRef;

    // Stav pro editaci
    private bool editingTitle = false;
    private string htmlPreview = "<i>Načítání...</i>";

    // Using a property with custom logic for editingDescription
    private bool _editingDescription = false;
    private bool editingDescription
    {
        get => _editingDescription;
        set
        {
            _editingDescription = value;
            if (!value) // If switching to preview mode
            {
                _ = UpdateHtmlPreview();
            }
        }
    }

    private int? editingCommentId = null;
    private int? replyingToId = null;
    private string newComment = "";
    private string replyText = "";
    private string activeEditor = "";
    private IJSObjectReference? _jsModule;
    private IJSObjectReference? _imageModule;

    // Dictionary to store image data with placeholders
    private Dictionary<string, string> imageDataCache = new();
    private int imageCounter = 0;

    // Barvy pro formátování textu
    private string[] colors = new[] { "#f44336", "#e91e63", "#9c27b0", "#673ab7", "#3f51b5",
                                      "#2196f3", "#03a9f4", "#00bcd4", "#009688", "#4caf50",
                                      "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722" };

    // Dummy data pro komentáře - v reálné aplikaci by byla načtena z API
    private List<TaskComment> comments = new List<TaskComment>
    {
        new TaskComment { Id = 1, Text = "Toto je první komentář k úkolu.", CreatedAt = DateTime.Now.AddDays(-2) },
        new TaskComment { Id = 2, Text = "Druhý komentář s **formátováním** a [odkazem](https://example.com).", CreatedAt = DateTime.Now.AddDays(-1) },
        new TaskComment { Id = 3, Text = "Odpověď na první komentář s kódem: ```csharp\nvar x = 10;\n```", ParentCommentId = 1, CreatedAt = DateTime.Now.AddHours(-5) }
    };

    // Model pro komentáře
    public class TaskComment
    {
        public int Id { get; set; }
        public string Text { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; } = DateTime.Now;
        public int? ParentCommentId { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Explicitly check if the task has a description
            if (!string.IsNullOrEmpty(task.Description))
            {
                await JS.InvokeVoidAsync("console.log", "Initial task description:",
                    task.Description.Length > 100 ? task.Description.Substring(0, 100) + "..." : task.Description);

                // First, check for image placeholders and restore from localStorage
                await RestoreImagesFromLocalStorage();

                // Process any large images for the current session
                await ProcessImagesInDescription();

                // Initialize the preview
                await UpdateHtmlPreview();
            }
            else
            {
                htmlPreview = "<i>Žádný obsah</i>";
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", "Error initializing task:", ex.Message);
            htmlPreview = "<i>Chyba při načítání obsahu</i>";
        }

        await base.OnInitializedAsync();
    }
    private async Task RestoreImagesFromLocalStorage()
    {
        try
        {
            if (string.IsNullOrEmpty(task.Description)) return;

            // Find image placeholders in the description
            var placeholderMatches = System.Text.RegularExpressions.Regex.Matches(
                task.Description,
                @"!\[([^\]]*)\]\(IMG:([a-z0-9_-]+)\)"
            );

            if (placeholderMatches.Count > 0)
            {
                await JS.InvokeVoidAsync("console.log", $"Found {placeholderMatches.Count} image placeholders to restore from localStorage");

                // Check each placeholder for localStorage data
                foreach (System.Text.RegularExpressions.Match match in placeholderMatches)
                {
                    string placeholderId = match.Groups[2].Value;

                    // Try to get the image data from localStorage
                    if (_imageModule != null)
                    {
                        try
                        {
                            string imageData = await _imageModule.InvokeAsync<string>("getImageData", placeholderId);
                            if (!string.IsNullOrEmpty(imageData))
                            {
                                // If found in localStorage, add to our in-memory cache for this session
                                imageDataCache[placeholderId] = imageData;
                                await JS.InvokeVoidAsync("console.log", $"Restored image {placeholderId} from localStorage");
                            }
                        }
                        catch (Exception ex)
                        {
                            await JS.InvokeVoidAsync("console.error", $"Error retrieving image {placeholderId} from localStorage: {ex.Message}");
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error restoring images from localStorage: {ex.Message}");
        }
    }
    private async Task ProcessImagesInDescription()
    {
        try
        {
            if (string.IsNullOrEmpty(task.Description)) return;

            // Find large image URLs in the description (data:image)
            var matches = System.Text.RegularExpressions.Regex.Matches(
                task.Description,
                @"!\[([^\]]*)\]\((data:image\/[^)]+)\)"
            );

            if (matches.Count > 0)
            {
                await JS.InvokeVoidAsync("console.log", $"Found {matches.Count} inline images to process");

                // Create a copy of the description to work with
                string processedDescription = task.Description;

                // Process each large image
                foreach (System.Text.RegularExpressions.Match match in matches)
                {
                    try
                    {
                        // Extract the alt text and image data
                        string altText = match.Groups[1].Value;
                        string imageData = match.Groups[2].Value;

                        // Generate a new placeholder
                        string placeholderId = $"img_{++imageCounter}";
                        string placeholderUrl = $"IMG:{placeholderId}";

                        // Store the actual data in both memory cache and localStorage
                        imageDataCache[placeholderId] = imageData;

                        if (_imageModule != null)
                        {
                            await _imageModule.InvokeVoidAsync("storeImageData", placeholderId, imageData);
                        }

                        await JS.InvokeVoidAsync("console.log", $"Processed inline image to {placeholderId} and stored in localStorage");

                        // Replace the large URL with the placeholder
                        string originalText = match.Value;
                        string replacementText = $"![{altText}]({placeholderUrl})";

                        processedDescription = processedDescription.Replace(originalText, replacementText);
                    }
                    catch (Exception ex)
                    {
                        await JS.InvokeVoidAsync("console.error", $"Error processing image match: {ex.Message}");
                    }
                }

                // Update the task description with the processed version
                task.Description = processedDescription;
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error processing images in description: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Použijeme nový JS soubor
                string version = DateTime.Now.Ticks.ToString();
                _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                    "import", $"./js/enterHandler.js?v={version}");

                // Load the image handler module
                _imageModule = await JS.InvokeAsync<IJSObjectReference>(
                    "import", $"./js/imageHandler.js?v={version}");

                // Nastavíme globální listenery pro Enter
                await _jsModule.InvokeVoidAsync("setupEnterHandling");

                // Initial preview update
                await UpdateHtmlPreview();

                // Přidáme styl pro zachování výšky textových polí
                await JS.InvokeVoidAsync("eval", @"
                    const style = document.createElement('style');
                    style.textContent = `
                        .mud-input.mud-input-outlined .mud-input-slot.mud-input-root-outlined {
                            min-height: auto !important;
                        }
                        .description-editor .mud-input-slot.mud-input-root-outlined textarea {
                            min-height: 250px !important;
                        }
                    `;
                    document.head.appendChild(style);
                ");
            }
            catch (Exception ex)
            {
                await JS.InvokeVoidAsync("console.error", $"Chyba při inicializaci: {ex.Message}");
            }
        }
    }

    // Method to update the HTML preview
    private async Task UpdateHtmlPreview()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(task.Description))
            {
                htmlPreview = "<i>Žádný obsah</i>";
                return;
            }

            // First, find and process all image placeholders
            var placeholderMatches = System.Text.RegularExpressions.Regex.Matches(
                task.Description,
                @"!\[([^\]]*)\]\(IMG:([a-z0-9_-]+)\)"
            );

            string processedMarkdown = task.Description;

            foreach (System.Text.RegularExpressions.Match match in placeholderMatches)
            {
                string altText = match.Groups[1].Value;
                string placeholderId = match.Groups[2].Value;

                // Try memory cache first
                string imageData = null;
                imageDataCache.TryGetValue(placeholderId, out imageData);

                // If not in memory, try localStorage
                if (string.IsNullOrEmpty(imageData) && _imageModule != null)
                {
                    imageData = await _imageModule.InvokeAsync<string>("getImageData", placeholderId);

                    // If found in localStorage, cache it in memory too
                    if (!string.IsNullOrEmpty(imageData))
                    {
                        imageDataCache[placeholderId] = imageData;
                    }
                }

                // Replace placeholder with either the image or a placeholder div
                string replacementHtml;
                if (!string.IsNullOrEmpty(imageData))
                {
                    replacementHtml = $"<img src=\"{imageData}\" alt=\"{altText}\" style=\"max-width:100%; border-radius:4px; display:block; margin:8px 0;\">";
                }
                else
                {
                    replacementHtml = $"<div class=\"image-placeholder\">Obrázek nenalezen</div>";
                }

                // Replace this placeholder in the markdown with HTML directly
                // This is a hack to get inline HTML into the markdown before conversion
                processedMarkdown = processedMarkdown.Replace(match.Value, replacementHtml);
            }

            // Now convert the rest of the markdown
            htmlPreview = await ConvertMarkdownToHtmlAsync(processedMarkdown);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error updating preview: {ex.Message}");
            htmlPreview = $"<i>Chyba při načítání obsahu: {ex.Message}</i>";
        }
    }

    // Improved method to convert markdown to HTML
    private async Task<string> ConvertMarkdownToHtmlAsync(string markdown)
    {
        if (string.IsNullOrWhiteSpace(markdown)) return "<i>Žádný obsah</i>";

        try
        {
            var html = markdown;

            // First, handle image placeholders - IMG:{id} format
            // We need to do this with a loop rather than Regex.Replace with async lambda
            var placeholderMatches = System.Text.RegularExpressions.Regex.Matches(
                html,
                @"!\[([^\]]*)\]\(IMG:([a-z0-9_-]+)\)"
            );

            // Process each placeholder synchronously after gathering data
            if (placeholderMatches.Count > 0)
            {
                // Create a list of replacements to make
                var replacements = new List<(string Original, string Replacement)>();

                foreach (System.Text.RegularExpressions.Match match in placeholderMatches)
                {
                    var alt = match.Groups[1].Value;
                    var placeholderId = match.Groups[2].Value;
                    string imageData = null;

                    // First try to get image data from in-memory cache
                    if (imageDataCache.TryGetValue(placeholderId, out var cachedData))
                    {
                        imageData = cachedData;
                    }
                    // If not in memory, try localStorage via JavaScript
                    else if (_imageModule != null)
                    {
                        try
                        {
                            string localStorageImage = await _imageModule.InvokeAsync<string>("getImageData", placeholderId);
                            if (!string.IsNullOrEmpty(localStorageImage))
                            {
                                // Store in memory cache for future use
                                imageDataCache[placeholderId] = localStorageImage;
                                imageData = localStorageImage;
                            }
                        }
                        catch (Exception ex)
                        {
                            await JS.InvokeVoidAsync("console.error", $"Error retrieving image from localStorage: {ex.Message}");
                        }
                    }

                    // Create HTML for image or placeholder
                    string replacementHtml;
                    if (!string.IsNullOrEmpty(imageData))
                    {
                        replacementHtml = $"<img src=\"{imageData}\" alt=\"{alt}\" style=\"max-width:100%; border-radius:4px; display:block; margin:8px 0;\">";
                    }
                    else
                    {
                        replacementHtml = $"<div class=\"image-placeholder\">Obrázek nenalezen</div>";
                    }

                    // Add to our replacements list
                    replacements.Add((match.Value, replacementHtml));
                }

                // Now apply all replacements to the HTML
                foreach (var (original, replacement) in replacements)
                {
                    html = html.Replace(original, replacement);
                }
            }

            // Process any data URLs directly in the markdown
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"!\[([^\]]*)\]\((data:image[^)]+)\)",
                match =>
                {
                    var alt = match.Groups[1].Value;
                    var imageData = match.Groups[2].Value;

                    return $"<img src=\"{imageData}\" alt=\"{alt}\" style=\"max-width:100%; border-radius:4px; display:block; margin:8px 0;\">";
                }
            );

            // Process regular images (normal URLs)
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"!\[([^\]]*)\]\(([^)]+)\)",
                "<img src=\"$2\" alt=\"$1\" style=\"max-width:100%; border-radius:4px; display:block; margin:8px 0;\">"
            );

            // Process headings
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"^# (.+)$",
                "<h1>$1</h1>",
                System.Text.RegularExpressions.RegexOptions.Multiline
            );

            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"^## (.+)$",
                "<h2>$1</h2>",
                System.Text.RegularExpressions.RegexOptions.Multiline
            );

            // Bold text - must be pairs ** **
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"\*\*([^*]+)\*\*",
                "<strong>$1</strong>"
            );

            // Italic text - must be pairs * *
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"\*([^*]+)\*",
                "<em>$1</em>"
            );

            // Strikethrough - must be pairs ~~ ~~
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"\~\~([^~]+)\~\~",
                "<s>$1</s>"
            );

            // Links
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"\[([^\]]+)\]\(([^)]+)\)",
                "<a href=\"$2\" target=\"_blank\">$1</a>"
            );

            // Code blocks
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"```(.*?)\n([\s\S]*?)```",
                "<pre><code class=\"language-$1\">$2</code></pre>",
                System.Text.RegularExpressions.RegexOptions.Singleline
            );

            // Inline code
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"`([^`]+)`",
                "<code>$1</code>"
            );

            // Colored text
            html = System.Text.RegularExpressions.Regex.Replace(
                html,
                @"<span style=""color: ([^;]+);"">([^<]+)</span>",
                "<span style=\"color: $1;\">$2</span>"
            );

            // Replace newlines with <br/>
            html = html.Replace("\n", "<br />");

            return html;
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error converting markdown to HTML: {ex.Message}");
            return $"<i>Error rendering content: {ex.Message}</i>";
        }
    }

    // Optimized image insertion method
    private async Task InsertImage()
    {
        try
        {
            // Show a loading indicator
            await JS.InvokeVoidAsync("eval", "document.body.style.cursor = 'wait';");

            var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.ExtraSmall };
            var parameters = new DialogParameters();

            var result = await DialogService.ShowAsync<ImageUrlDialog>("Vložit obrázek", parameters, options);
            var dialogResult = await result.Result;

            if (!dialogResult.Canceled && dialogResult.Data is string imageUrl && !string.IsNullOrEmpty(imageUrl))
            {
                // Optimize the image if it's a data URL
                if (imageUrl.StartsWith("data:") && _imageModule != null)
                {
                    try
                    {
                        imageUrl = await _imageModule.InvokeAsync<string>("optimizeImage", imageUrl, 800, 600, 0.7);
                    }
                    catch (Exception ex)
                    {
                        await JS.InvokeVoidAsync("console.error", $"Error optimizing image: {ex.Message}");
                    }
                }

                string markdownImage;

                // Check if this is a data URL (base64)
                if (imageUrl.StartsWith("data:"))
                {
                    // Generate a placeholder
                    string placeholderId = $"img_{++imageCounter}";
                    string placeholderUrl = $"IMG:{placeholderId}";

                    // Store the actual data in memory
                    imageDataCache[placeholderId] = imageUrl;

                    // Also store in localStorage for persistence between sessions
                    if (_imageModule != null)
                    {
                        try
                        {
                            await _imageModule.InvokeVoidAsync("storeImageData", placeholderId, imageUrl);
                            await JS.InvokeVoidAsync("console.log", $"Stored image in localStorage: {placeholderId}");
                        }
                        catch (Exception ex)
                        {
                            await JS.InvokeVoidAsync("console.error", $"Error storing image in localStorage: {ex.Message}");
                        }
                    }

                    // Use the placeholder in the markdown
                    markdownImage = $"![Obrázek]({placeholderUrl})";
                }
                else
                {
                    // For regular URLs, use as is
                    markdownImage = $"![Obrázek]({imageUrl})";
                }

                // Insert the markdown
                if (editingDescription)
                {
                    // Direct manipulation of description for better performance
                    task.Description += markdownImage;
                    StateHasChanged();
                }
                else
                {
                    // For other contexts use standard method
                    await InsertMarkdownAsync(markdownImage, "");
                }

                // Update preview if needed
                if (!editingDescription)
                {
                    await UpdateHtmlPreview();
                }
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Chyba při vkládání obrázku: {ex.Message}");
        }
        finally
        {
            // Reset cursor
            await JS.InvokeVoidAsync("eval", "document.body.style.cursor = 'default';");
        }
    }

    // Metoda pro vložení textu na pozici kurzoru
    private async Task InsertMarkdownAsync(string startTag, string endTag)
    {
        try
        {
            if (_jsModule == null) return;

            string textAreaId;

            // Jednoduché mapování bez složité metody
            if (activeEditor == "description")
                textAreaId = "description-textarea";
            else if (activeEditor == "newComment")
                textAreaId = "new-comment-textarea";
            else if (activeEditor == "reply")
                textAreaId = "reply-textarea";
            else if (activeEditor.StartsWith("comment_"))
                textAreaId = $"comment-textarea-{activeEditor.Substring(8)}";
            else if (editingDescription)
                textAreaId = "description-textarea";
            else
                textAreaId = "new-comment-textarea";

            // Volání JS funkce pro vložení textu
            await _jsModule.InvokeVoidAsync("insertTextAtCursor", textAreaId, startTag, endTag);
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Chyba při vkládání formátování: {ex.Message}");
        }
    }

    // Submit method with improved error handling
    private async Task Submit()
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", "Saving task with placeholders:",
                task.Description.Length > 100 ? task.Description.Substring(0, 100) + "..." : task.Description);

            // Get the full description with resolved images
            string fullDescription = await GetDescriptionWithFullImageData();

            // Create a copy of the task for saving
            var taskToSave = new TaskItem
                {
                    Id = task.Id,
                    Title = task.Title,
                    Description = fullDescription,
                    ColumnId = task.ColumnId,
                    Order = task.Order,
                    DueDate = task.DueDate,
                    Priority = task.Priority
                };

            // Close the dialog with the fully restored task data
            MudDialog.Close(DialogResult.Ok(taskToSave));
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error in Submit: {ex.Message}");

            // Fallback to simple submit
            MudDialog.Close(DialogResult.Ok(task));
        }
    }

    // Improved method to get description with full image data
    private async Task<string> GetDescriptionWithFullImageData()
    {
        string fullDescription = task.Description;

        try
        {
            // Find all image placeholders in the description
            var matches = System.Text.RegularExpressions.Regex.Matches(
                task.Description,
                @"!\[([^\]]*)\]\(IMG:([a-z0-9_-]+)\)"
            );

            await JS.InvokeVoidAsync("console.log", $"Found {matches.Count} placeholders to restore");

            // Replace each placeholder with the actual data
            foreach (System.Text.RegularExpressions.Match match in matches)
            {
                if (match.Groups.Count >= 3)
                {
                    string placeholderId = match.Groups[2].Value;
                    string altText = match.Groups[1].Value;

                    if (imageDataCache.TryGetValue(placeholderId, out var imageData))
                    {
                        string placeholder = match.Value;
                        fullDescription = fullDescription.Replace(placeholder, $"![{altText}]({imageData})");
                        await JS.InvokeVoidAsync("console.log", $"Restored image {placeholderId}");
                    }
                    else
                    {
                        await JS.InvokeVoidAsync("console.warn", $"Could not find image data for {placeholderId}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error restoring image data: {ex.Message}");
        }

        return fullDescription;
    }

    private void Cancel() => MudDialog.Cancel();

    // Nová metoda pro zpracování klávesy Enter s možností zabránění výchozímu chování
    private async Task HandleKeyDownWithPreventDefault(KeyboardEventArgs e, string editorId)
    {
        try
        {
            if (_jsModule == null) return;

            // Zpracováváme pouze Enter
            if (e.Key == "Enter" && !e.ShiftKey)
            {
                string textAreaId;

                // Jednoduché mapování
                if (editorId == "description")
                    textAreaId = "description-textarea";
                else if (editorId == "newComment")
                    textAreaId = "new-comment-textarea";
                else if (editorId == "reply")
                    textAreaId = "reply-textarea";
                else if (editorId.StartsWith("comment_"))
                    textAreaId = $"comment-textarea-{editorId.Substring(8)}";
                else
                    return;

                // Zpracujeme seznam
                bool handled = await _jsModule.InvokeAsync<bool>("processListItem", textAreaId);

                // Pokud bylo zpracování úspěšné, zabráníme výchozímu chování
                if (handled)
                {
                    // Výchozí chování je zabráněno v JS kódu
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Chyba při zpracování klávesy: {ex.Message}");
        }
    }

    // Metody pro práci s komentáři
    private void SetReplyingTo(int id)
    {
        replyingToId = id;
        replyText = "";
    }

    private void SetEditingComment(int? id)
    {
        editingCommentId = id;
    }

    private void SetActiveEditor(string editorId)
    {
        activeEditor = editorId;
    }

    private void UpdateReplyText(string text)
    {
        replyText = text;
    }

    // Metody pro práci s komentáři
    private void AddComment()
    {
        if (string.IsNullOrWhiteSpace(newComment)) return;

        var comment = new TaskComment
            {
                Id = comments.Any() ? comments.Max(c => c.Id) + 1 : 1,
                Text = newComment,
                CreatedAt = DateTime.Now
            };

        comments.Add(comment);
        newComment = "";
    }

    private void AddReply(int parentId, string replyText)
    {
        if (string.IsNullOrWhiteSpace(replyText)) return;

        var reply = new TaskComment
            {
                Id = comments.Any() ? comments.Max(c => c.Id) + 1 : 1,
                Text = replyText,
                ParentCommentId = parentId,
                CreatedAt = DateTime.Now
            };

        comments.Add(reply);
        this.replyText = "";
        replyingToId = null;
    }

    private void DeleteComment(int id)
    {
        // Odstranění komentáře a jeho odpovědí (rekurzivně)
        DeleteCommentRecursive(id);
    }

    private void DeleteCommentRecursive(int commentId)
    {
        // Najdeme všechny odpovědi
        var replies = comments.Where(c => c.ParentCommentId == commentId).ToList();

        // Rekurzivně odstraníme všechny odpovědi
        foreach (var reply in replies)
        {
            DeleteCommentRecursive(reply.Id);
        }

        // Odstraníme samotný komentář
        var comment = comments.FirstOrDefault(c => c.Id == commentId);
        if (comment != null)
        {
            comments.Remove(comment);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_jsModule is not null)
        {
            await _jsModule.DisposeAsync();
        }

        if (_imageModule is not null)
        {
            await _imageModule.DisposeAsync();
        }
    }

    [Inject] IDialogService DialogService { get; set; } = default!;
}